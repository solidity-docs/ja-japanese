.. index:: ! constant

.. _constants:

****************************************
定数の状態変数とイミュータブルの状態変数
****************************************

状態変数は ``constant`` または ``immutable`` として宣言できます。
どちらの場合も、コントラクトが構築された後は、変数を変更できません。
``constant`` 変数の場合はコンパイル時に値を固定する必要がありますが、 ``immutable`` の場合はコンストラクション時にも値を代入できます。

また、ファイルレベルで ``constant`` 変数を定義することも可能です。

コンパイラはこれらの変数のためにストレージスロットを確保しておらず、出現するたびにそれぞれの値で置き換えられます。

.. Compared to regular state variables, the gas costs of constant and immutable variables
.. are much lower. For a constant variable, the expression assigned to it is copied to
.. all the places where it is accessed and also re-evaluated each time. This allows for local
.. optimizations. Immutable variables are evaluated once at construction time and their value
.. is copied to all the places in the code where they are accessed. For these values,
.. 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values
.. can sometimes be cheaper than immutable values.

通常の状態変数と比較して、定数変数やイミュータブル変数のガスコストは非常に低くなります。
定数変数の場合、それに割り当てられた式は、アクセスされるすべての場所にコピーされ、また毎回再評価されます。
これにより、局所的な最適化が可能になります。
イミュータブルの変数は、構築時に一度だけ評価され、その値はコード内のアクセスされるすべての場所にコピーされます。
これらの値のために、たとえそれより少ないバイト数で収まるとしても、32バイトが確保されます。
このため、定数値の方がイミュータブル値よりもコストが低い場合があります。

現時点では、定数やイミュータブルのすべての型が実装されているわけではありません。
サポートされているのは、 :ref:`strings <strings>` （定数のみ）と :ref:`値型<value-types>` のみです。

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.4;

    uint constant X = 32**22 + 8;

    contract C {
        string constant TEXT = "abc";
        bytes32 constant MY_HASH = keccak256("abc");
        uint immutable decimals;
        uint immutable maxBalance;
        address immutable owner = msg.sender;

        constructor(uint decimals_, address ref) {
            decimals = decimals_;
            // Assignments to immutables can even access the environment.
            maxBalance = ref.balance;
        }

        function isBalanceTooHigh(address other) public view returns (bool) {
            return other.balance > maxBalance;
        }
    }

定数
====

.. For ``constant`` variables, the value has to be a constant at compile time and it has to be
.. assigned where the variable is declared. Any expression
.. that accesses storage, blockchain data (e.g. ``block.timestamp``, ``address(this).balance`` or
.. ``block.number``) or
.. execution data (``msg.value`` or ``gasleft()``) or makes calls to external contracts is disallowed. Expressions
.. that might have a side-effect on memory allocation are allowed, but those that
.. might have a side-effect on other memory objects are not. The built-in functions
.. ``keccak256``, ``sha256``, ``ripemd160``, ``ecrecover``, ``addmod`` and ``mulmod``
.. are allowed (even though, with the exception of ``keccak256``, they do call external contracts).

``constant`` 変数については、コンパイル時に値が定数である必要があり、変数が宣言された場所で代入されなければなりません。
ストレージ、ブロックチェーンデータ（例:  ``block.timestamp`` 、 ``address(this).balance`` 、 ``block.number`` ）、実行データ（ ``msg.value`` 、 ``gasleft()`` ）にアクセスしたり、外部コントラクトを呼び出したりする式はすべて許可されていません。
メモリの割り当てに副作用を及ぼす可能性のある式は許可されますが、他のメモリオブジェクトに副作用を及ぼす可能性のある式は許可されません。
組み込み関数の ``keccak256`` 、 ``sha256`` 、 ``ripemd160`` 、 ``ecrecover`` 、 ``addmod`` 、 ``mulmod`` は許可されています（ ``keccak256`` を除いて外部コントラクトをコールしていますが）。

.. The reason behind allowing side-effects on the memory allocator is that it
.. should be possible to construct complex objects like e.g. lookup-tables.
.. This feature is not yet fully usable.

メモリアロケータの副作用を許可した理由は、ルックアップテーブルなどの複雑なオブジェクトを構築できるようにするためです。
この機能はまだ完全には使用できません。

イミュータブル
==============

<<<<<<< HEAD
.. Variables declared as ``immutable`` are a bit less restricted than those
.. declared as ``constant``: Immutable variables can be assigned an arbitrary
.. value in the constructor of the contract or at the point of their declaration.
.. They can be assigned only once and can, from that point on, be read even during
.. construction time.

``immutable`` として宣言された変数は、 ``constant`` として宣言された変数よりも少し制限があります。
イミュータブルの変数は、コントラクトのコンストラクタや宣言の時点で、任意の値を代入できます。
それらは一度だけ代入でき、その時点からコンストラクション中でも読み取ることができます。

.. The contract creation code generated by the compiler will modify the contract's runtime code before it is returned by replacing all references to immutables with the values assigned to them.
.. This is important if you are comparing the runtime code generated by the compiler with the one actually stored in the blockchain.

コンパイラが生成したコントラクト作成コードは、イミュータブルへのすべての参照をイミュータブルに割り当てられた値に置き換えることで、コントラクトのランタイムコードを返す前に修正します。
これは、コンパイラによって生成されたランタイムコードと、実際にブロックチェーンに保存されているランタイムコードを比較する場合に重要です。

.. .. note::

..   Immutables that are assigned at their declaration are only considered
..   initialized once the constructor of the contract is executing.
..   This means you cannot initialize immutables inline with a value
..   that depends on another immutable. You can do this, however,
..   inside the constructor of the contract.

..   This is a safeguard against different interpretations about the order
..   of state variable initialization and constructor execution, especially
..   with regards to inheritance.
=======
The contract creation code generated by the compiler will modify the
contract's runtime code before it is returned by replacing all references
to immutables with the values assigned to them. This is important if
you are comparing the
runtime code generated by the compiler with the one actually stored in the
blockchain. The compiler outputs where these immutables are located in the deployed bytecode
in the ``immutableReferences`` field of the :ref:`compiler JSON standard output <compiler-api>`.
>>>>>>> english/develop

.. note::

    宣言時に代入されたイミュータブルは、コントラクトのコンストラクタが実行されて初めて初期化されたとみなされます。
    つまり、他のイミュータブルに依存する値でイミュータブルをインラインで初期化できません。
    ただし、コントラクトのコンストラクタの内部では初期化できます。

    これは、状態変数の初期化とコンストラクタの実行の順序について、特に継承に関して異なる解釈がなされないようにするための措置です。
